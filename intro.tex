
\section{Introduction}
Blockchain systems have gained significant attention in recent years. The central problem of blockchain is to extend an ordered chain of transactions and reaching consensus among decentralized nodes. While many consensus protocols have been proposed to solve this problem, most of them only consider consistency and liveness properties. Consistency means every node have the same view of the chain or its prefix. Liveness means that new transactions are eventually added to the chain. 

One important yet little studied property is \emph{fairness} in transaction ordering. Fairness means that the order of transactions in the chain should reflect the order in which they were received by the nodes. This property is important for several reasons. First, it helps prevent attacks by manipulating the order of transactions, such as front-running attacks and sandwich attacks. Second, it ensures that users have a fair chance of having their transactions included in the chain. The challenge to achieve transaction order fairness lies in the fact that nodes may receive transaction requests at different times due to network delays. It is nontrivial to reach consensus on the order of transactions being received, especially in the presence of malicious nodes that may try to manipulate the order for their own benefit. 

The formal study of transaction order fairness was initiated by the seminar work of Kelkar et al. \cite{DBLP:conf/crypto/Kelkar0GJ20}. They defined \textit{receive-order-fairness} which requires all honoest nodes to output a transaction $\tx$ before another transaction $\tx'$ if sufficiently many nodes receive $\tx$ before $\tx'$. This fairness definition intuitively corresponds to the notion of ``first received, first output''. Kelkar et al. showed that the definition is impossible to achieve due to a scenario called Condorcet paradox which causes a non-transitive global ordering even when all local orderings are transitive. In the example of $n$ nodes and $n$ transactions, node $1$ receives transactions in the order $[\tx_1, \tx_2,\dots, \tx_n]$ and each other node $i$ in the order of $[\tx_i, \tx_{i+1}, \dots, \tx_n, \tx_1, \dots, \tx_{i-1}]$. We have that $n-1$ nodes receive $\tx_j$ before $\tx_{j+1}$ for $j$ in $1,\dots, n$. However, $n-1$ nodes receive $\tx_n$ before $\tx_1$. This creates a cycle in the global ordering: $\tx_1 \prec \tx_2 \prec \dots \prec \tx_n \prec \tx_1$. 

To circumvent this impossibility, Kelkar et al. proposed a relaxed definition called \textit{block-order-fairness}. It states that when sufficiently many nodes receive $\tx$ before $\tx'$, then no honest node can deliver $\tx$ in a block after $\tx'$. The relaxation allows $\tx$ to be placed after $\tx'$ as long as they are delivered in the same block. This relation evade the Condorcet paradox by placing paradoxical orderings into the same block. It gives malicious miners sufficient flexibility to manipulate the order of transactions. For example, if the attacker finds a transaction $\tx_1$ that is suitable for a front-running attack by a transaction $\tx_2$, the attack will be successful when the miner adds both transactions into the same block with $\tx_2$ before $\tx_1$. Such a block is valid as long as it includes all transactions received between $\tx_1$ and $\tx_2$. This implies that the attacker has suffcient time to prepare its attack transaction $\tx_2$, up to the time to generate a block. In blockchain systems where consensus/finality on blocks is achieved within each slot, the block time at least includes a few rounds of messages propagating among the network.  They presented a protocol called $\mathsf{Aequitas}$ that achieves the block-order-fairness. 

\comment{In Ethereum PoS, the delay to generate a block is $1\Delta$, because block proposers must receive the old block before producing the new block. It is not $2\Delta$ (to also receive enough votes on the old block) because Ethereum PBFT style consensus only runs once in an epoch. \newline However, Ethereum plans to achieve SSF (single-slot-finality). Each block time consists of the time to conduct two phases of voting. So a block time will be much longer than message delay time. \newline In consensus that supports transaction ordering, voting-consensus per slot is necessary. } 

One limitation of block-order fairness is that it allows malicious miners to re-order transactions within each block even if there is no paradoxical ordering. In other words, it is designed to withstand the worst case paradoxical ordering, such as a paradoxical cycle that takes up an entire block, but cannot achieve best-effort fairness when it is not the worst case. Kiayias et al. \cite{DBLP:conf/eurocrypt/KiayiasLS24} presents a more fine-grained relaxation of receive-order-fairness, which they call \textit{bounded unfairness}. Bounded unfairness parameterized by a bound $B$ states that for two transactions $\tx,\tx'$, if sufficiently many nodes receive $\tx$ before $\tx'$, then $\tx$ cannot be placed more than $B$ transactions later compared to $\tx'$. Bounded unfairness tries to find the minimum $B$. When $B$ is much smaller than the number of transactions in a block, it allows for a more fine-grained control over transaction ordering compared to block-order-fairness. Moreover, they showed the connection between finding the minimum bound $B$ and finding the directed bandwidth of a graph. As a result, the problem is NP-hard and also hard to approximate for an constant ratio. 

Kiayias et al. \cite{DBLP:conf/eurocrypt/KiayiasLS24} also presents a variation of their protocol to handle long paradoxical cycles. Assuming transaction dissemination delay is bounded by $\Delta_{\tx}$, they showed that $B$ is bounded by at most $3$ times the maximum number of transactions disseminated concurrrently within a $\Delta_{\tx}$ time window. They use median timestamp to order these transactions and achieve \textit{timed-directed-bandwidth-fairness}. 

Regarding performance, their protocol, called $\mathsf{Taxis}$, runs exponentially on the number of edges of the subgraph of the transaction graph that is defined by the (largest) Condorcet cycle. This is undesirable in practice. 


In this work, we present another fairness notion, which we call \textit{time-delayed-fairness}. We relax from receive-order-fairness differently, by changing to condition to impose a pairwise ordering requirement. Our fairness parameterized by delay $\thtime$ states that if sufficiently nodes receive $\tx$ at least $\thtime$ time before $\tx'$, then $\tx$ should be delivered before $\tx'$. We also analyze the parameter $\varphi$, the threshold for ratio of nodes for a transaction to be considered ``receive'' before another. Assuming a transaction dissemination delay of $\synctime$, we show that our fairness gets rid of the Condorcet paradox under suitable parameter choices. In detail, it is $\thtime>\synctime/k$ when $\varphi>1-h/k$, where $h$ is the ratio of honest nodes and $k$ is a positive integer. Compared with $\mathsf{Aequitas}$, our protocol is more fine-grained and achieves the best-possible fairness when there are few Condorcet cycles. Compared with $\mathsf{Taxis}$, our protocol runs in polynomial time and achieves concretely better time delayed fairness. 

\comment{It's good to have an example. Given a sequence, we output better ordering. }


\begin{definition}[Time-Delayed-Fairness]\label{def:timed-fairness}
    A protocol achieves time-delayed-fairness with parameters $\thtime$ and $\varphi$ if for any two transactions $\tx$ and $\tx'$, if at least $\varphi$ fraction of honest nodes receive $\tx$ at least $\thtime$ time before receiving $\tx'$, then every honest node delivers $\tx$ before $\tx'$.
\end{definition}
